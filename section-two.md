# Section Two - Code Deployment and CICD/GitFlow at Scale
## Iteration One - Enabling GitFlow an Bronze
You might be anxious to get more tables loaded and you can do this next if you want to.  If that's the case, skip to the next Iteration.  But if you're up for the challenge, in this iteration we'll be working on setting up the CICD pipelines and automation to deploy our code from dev to prod.  We'll just have two environments in this exercise so keep us moving, but most medallion architectures will have more that just two.

The first thing we'll need to do is associate our workspaces with a Git repository.  This can be either GitHub or Azure Devops.  Either one works.  Azure Devops might be a little easier becuase you don't need to deal with PATs and you just use your EntraID to authenticate.  But use whatever is easier to get your hands on.  The deployment pipeline technology is almost identical so even those won't differ much between the two.

Ok - I'm going to make an assumption that you have a workspace for your Bronze layer and one workspace for your Silver and Gold.  If you have separated Silver and Gold, that's totally fine.  You'll just end up with more workspaces when we are done.  Remember we're trying to go to at least 100 tenants so it might be easier to put Silver and Gold in the same workspace.  But this there really are multiple ways to make this work.

Now that you have Bronze under source control, you can start committing your code to the Git repository.  This is already an improvement over not having Git backed workspaces, but to take it to the next level, we need to enable developers to work at the same time without bumping into each other.  If a developer is changing a semantic model and renaming a column, and another developer is modifying a report that relies on that semantic model, then we need for these two developers to work on their own copy of the source code so that the developer working on modifying the report can complete this task without being interrupted or broken by the change in the semantic model.

This is done by using branches.  A branch is just a copy of the current source code in the reposoitory.  Developers can make changes on the new branch and then later merge it back into the main branch of the repository.  Fabric has capabilities to make this work and it is called Branch Out. This will create a new workspace and a new branch and bind them together.  These kinds of branches are commonly called 'feature branches'.  Developers work in that workspace and feature branch until they are done - at which point, the developer commits the final version of their code to the feature branch.  At that point, the developer creates a Pull Request in the Git reposotry - GitHub or Azure Devops - and this is the process by which the changes in the new branch are merged into the main branch - the main branch always holding the sum total of everything that has been merged back in.  This is the end of the road for the workspace and the feature branch that were created.  We can delete them both now.  You can delete the workspace in Fabric, but you'll have to go to your Git repo tool to delete the feature branch.

The last thing we need to do is create a branch policy.  There are multiple ways to create a policy that will achieve this, but this policy will force developers to develop on a branch and use a pull request to merge into main.  Developers will not be allowed to commit code to main directly.  This enforces the dicipline of using feature branches.

**Completion Criteria**

Bronze workspace will be bound to the main branch of a Git repository.  There will be a branch policy on main that forbits direct commits to main and merge will only be allowe by a pull request.

I'll give you a hint on how to set up your branch policy.  Go to the main branch and force approvals for merge on main.  The only way to do approvals is through a pull request.

## Iteration Two - Enable deploying to Prod for Bronze
You might notice that you don't really have a dev environmgnt *and* a prod environment.  You have essentially a prod workspace where you can branch out, do work, and then merge.  And this merge puts that code into production.  Without any chance to test prior.  This may actually work in some scenarios, but when working in an ISV environment, this risk is probably not tolerable.

So, how do we add a production environment?  We'll need a new workspace and we'll need to deploy our code from the dev Bronze workspace to the prod Bronze workspace.  There is more than one way to move the code from dev to prod.  One would be to add another permanent branch in the repo and bind that to prod and use Git to merge code from what would be the dev branch to the prod branch.  Once code is merged to the branch bound to prod, you'd then to a git sync in the prod workspace and this would bring the code from git repo into the prod workspace.  This a valid strategy for Bronze.  This strategy won't work when we get to Silver and Gold when we have hundreds of workspaces to deploy to, but for Bronze, it could work.

If this is the way you want to go, you'll need to add another long lived branch in your repo.  Let's say you leave main for your development and you add one called 'prod' for binding to your prod workspace.  You won't want to allow anyone to commit to this new 'prod' branch, not even from a feature branch.

If you'd rather solve this problem with something other than Git, read on.  The other way is to deploy from dev to prod using automation - meaning the Fabric API.  The Fabric API has everything we need to create, update, and delete items in a workspace.  Luckily we don't have to use the REST API, we can use the Fabric CLI, which makes the process of writing these scripts much easier.  If you want to use the REST API instead, that's totally fine.  Go for it.  But I think you'll save time using the CLI.

The idea here would be to run some scripting on Azure Devops or GitHub using Pipelines or Actions that when the pipeline runs, (I'm just going to use the generic, pipeline from now on) it takes the code that is ready to go to prod and deploys it directly from Git to the workspace.  If you've never looked at the Git repo behind a workspace, go ahead and take a look.  Each Fabric item is in a folder with its name and item type.  This will make it easy for us to identify what's what so that we can deploy everything correctly.

When our pipeline runs on worker in GitHub or Azure Devops, we need to get a copy of the code so we can deploye it.  On Azure Devops, this is already done for you, but on GitHub Actions, it is not.  So if your running in GitHub, you'll need to do what's called a checkout.

Now imagine yourself running a terminal session and in that terminal session, the code is now sitting in a directory right where the terminal is open.  You'd be able to write scripts that change directory into the Git reposotory and and do stuff with the code.  For us, we're going to want to go to the directories we need to and use the Fabric CLI to deploy the code.  The CLI already knows how to read the files, you just have to tell it where the files are and which workspace you want to put them in.

There is a question of order of operations here.  You might need to deploy a Fabric notebook before a Fabric pipeline because it references it.  Let's not worry too much about trying to detect these by inspecting the code in the Git repository.  You'll know in which order to deploy everything.  So when you write this script, just hard code the order.  The other issue we have is that a Fabric pipeline references a notebook, it does it by GUID.  But the GUIDs in the repo will be for the notebook in the development workspace.  But we want this deployment to have the production Fabric pipeline point to the production Fabric notebook, not the notebook in the dev workspace.  So you'll have to account for that too by ensuring the Fabric pipeline references the correct notebook.

By the way - while you can use the multiple branch method to get code from dev to prod in both your Bronze and the Silver and Gold workspaces, that strategy won't work for deploying from the Silver and Gold workspace to the hundred workspaces that are tenant facing.  You'll need to use this scripted CLI deployments strategy.  Also, if you end up with more environments than dev and prod, it might mean that using this second method makes more sense.  But all that really matters is that we get control of the CICD process in a way that reduces risk by controlling deploymens and increases quality by allowing for automated testing. Also, remember that the goal of this exercise is to understand better the tooling and options within Fabric to solve these problems.  This isn't meant as a best practices guide.  There really are no 'best pratices', just good practices.  Using your judgement to decide, is the art of this science.

## Iteration Three
 - CICD on Silver and Gold
This is going to be more tricky.  We know we are going to eventually have hundreds of tenant facing workspaces for Silver and Gold so we can't create a Git repository for each one.  We also know that we still need dev to prod depolyments for Silver and Gold.  And we also know that we're going to need to deploy this prod workspace out to at least 100 tenant facing workspaces.  We can't really manage hundreds of Git repositories, so we'll just be deploying the code out to these hundred workspaces using some scripting and automation without binding them to a Git repo.

So know that we have an idea how to build this, go ahead and build the same thing for Silver and Gold that you build for Bronze.  We're going to need the exact same thing.  a dev